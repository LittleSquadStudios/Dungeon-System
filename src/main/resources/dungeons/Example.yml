# Is PvP enabled?
pvp: false

# World in which is defined the dungeon (all the locations will refer to this world!)
world: "World"

display_name: "&6&k---&bExample&6&k---&r"

time:
  # Has the dungeon a per-party/per-player time limit?
  limited: true
  amount: 5
  # Time unit referred to the amount specified above,
  # supported units: [SECONDS, MINUTES, HOURS, DAYS]
  unit: MINUTES

# Any fallback command is independent of the message sent in case of failure or success (configurable in the messages.yml)
# If in party, all the commands are executed per-player in the party

# The entrance command has the format: /dungeon join <dungeon_id>.
# Since MMOCore doesn't provide a way to determine the party leader,
# we assume that the player who first runs the command acts as the "leader".
# Once that player starts the dungeon join process, other party members
# are prevented from executing the same command to avoid duplicate join attempts.
entrance:
  max_slots:
    # Limit the number of player allowed in the dungeon, exceptions:
    # - set to 0 for restricting the access to the dungeon
    # - set to -1 for allowing unlimited amount of players
    limit: 100
    bypass_permission: "azure_dungeon.bypass_slots"
    # Permit to join either if 'max_slots' is set to '0'
    admin_permission: "azure_dungeon.admin"
    # Commands to execute in case the player isn't allowed to enter for the 'max_slots' limit
    fall_back_commands:
      - "kill %player_name%"
  party:
    # Don't allow solo players to enter the dungeon if set to true
    required: true
    # Commands to execute in case the player isn't allowed to enter for the 'party' limit
    fall_back_commands:
      - "kill %player_name%"
  level:
    # A solo player must have at least the specified level to enter the dungeon
    personal_minimum: 10
    # Impose the limit cited above but for a party
    # The party level is the sum of the levels of all the party members
    party_minimum: 15
    # Commands to execute in case the player isn't allowed to enter for the 'level' limit
    fall_back_commands:
      - "kill %player_name%"
  # Commands to execute in case the player successfully enters the dungeon
  successful_entrance_commands:
    - "tp %player_name% 127 180 900"

events:
  # Any event in this section defines its identifier that will be used in commands
  # Example: /dungeon trigger 'first_event' %player_name%
  first_event:
    # The type of event: [TIMED, OBJECTIVE, STRUCTURAL]
    type: TIMED
    # The timed event is the simplest one: given a range of time, executes the given commands
    # Is fixed establish if the commands are executed AFTER the time has elapsed or randomly in the given range
    is_fixed: false
    time:
      amount: 1
      unit: MINUTES
    commands:
      - "say TIME!"
  # The objective is checked ONLY AFTER TRIGGERING THE EVENT!
  # So a command like "/dungeon trigger 'objective_event' %player_name%" have to be used before
  objective_event:
    type: OBJECTIVE
    # Supported options: [ALL, ANY]
    # Define if triggering the commands once ALL the requirements or ANY of the requirements are met
    requirement_mode: ALL
    # The evaluation of the requirements is done asynchronously since the cost of submitting
    # the tasks to an Executor is less than most of the computations
    #
    # The objective event triggers the given commands once the requirements are met
    requirements:
      # An internal parser will translate the requirements and construct a condition
      # given some fixed schemas, like: (parameter symbols: <> means required and [] means optional)
      # slay <amount> <MobType/MythicMobType>
      # interact <location x, y, z> [MobType/MythicMobType] (Specifying or not the mob type allows to distinguish entity interactions from block interactions)
      # near <location x, y, z> <radius>
      # enter <location x, y, z> <location x, y, z>
      # item <displayName> <amount>
      - "slay 100 ZOMBIE"
    # Leave this blank in case there is no associated checkpoint once this event gets fired
    checkpoint: "example"
    # Same for the boss-room
    boss-room: ""
    commands:
      - "say OBJECTIVE!"
  # A structural event is a special type of event that modify the structure of a dungeon through
  # any environmental change that is conditioned by other structural events, example:
  #
  #                    ------------------
  # __________________|                 |________________
  #    Entrance A         Boss Room         Entrance B
  # ------------------|________________|-----------------
  #
  # If the 'Entrance A' gets triggered and blocks the access, then the 'Entrance B' can't
  # get triggered, otherwise it'll completely lock the progresses in the dungeon
  #
  # The structural events are the only type of event that may trigger without any external
  # call and that exists in 2 states: ACTIVE or NOT_ACTIVE
  structural_event_A:
    type: STRUCTURAL
    # Supported environment events: [NONE, ROCK_SLIDES]
    # The ROCK_SLIDES event makes falling blocks of the given types and then occlude the passage
    # at a given location
    environment_event: NONE
    # Ignored for block independent events
    block_types:
      - "STONE"
    # Ignored for location independent events
    area: "-24 68 -24 -24 72 -28"
    # List of events where AT LEAST ONE should be NOT_ACTIVE for allowing this event to trigger
    conditioned_by:
      - "structural_event_B"
    commands:
      - "say STRUCTURAL!"
    time:
      # After how much time the re-scheduling is tried if the activation fail
      # The time is chosen randomly from 'min' to 'max'
      retry:
        time_min: 10
        time_max: 20
        unit: MINUTES
      # After how much time the event is deactivated in case of successful activation
      # The time is chosen randomly from 'min' to 'max'
      deactivation:
        time_min: 15
        time_max: 30
        unit: MINUTES

# The checkpoints are like save-points that gets activated once a OBJECTIVE
# event gets fired
#
# They may be used as respawn locations or simple progress marks
#
# Very useful when it's required to establish what happens AFTER reaching a
# certain checkpoint
# NOTE: It's used the term after since the effects are defined to happen
#       when the checkpoint gets unlocked since it's already done in the
#       'commands' section of the OBJECTIVE event
checkpoints:
  # Name of the checkpoint used in the 'checkpoint' section of the OBJECTIVE event
  # Each checkpoint should have a different name even across different files!
  first:
    location: "-40 66 -16"
    on_death_commands:
      - "tw trigger cinematic_"
  example:
    location: "-40 66 -16"
    # May be specified a precedent checkpoint too if this is only a 'technical' checkpoint
    respawn_at_checkpoint: "first"
    on_death_commands:
      - "kill %player_name%"

boss_rooms:
  # This might be named as you want, the only requirement is to make it different from the others
  main_boss_room:
    # Limit the number of players in the boss room
    max_players_in: 10
    max_one_party_at_a_time: true
    access_denied_commands:
      - "say NO!"
    # If not empty, the player will try to enter the given boss room in case of failure
    fallback_boss_room: ""
    # If the players can't immediately join this boss room and the 'fallback_boss_room'
    # option is empty, then the player will be enqueued until the other players get
    # kicked, so when the players will finally be allowed to access the boss room
    # the sequent commands will be executed!
    enqueuing_commands:
      - "say NOW YES!"
    # Configuration of the boss residing in the boss room
    boss:
      base_level: 50
      location: "30 70 -40"
      # For example a party of 2 players at level 45 or 3 players at level 30
      # If a player is not in party, then his level is considered the party level
      party_level: 90
      multiplier: 1.0
      exponent: 1.0
      # Limit the max level the boss can reach
      # The formula for the final level is: Max(max_level, Min(base_level, Pow((base_level + (real_party_level - party_level)) * multiplier, exponent)))
      # where 'real_party_level' is the only non-constant value
      max_level: 80
      # Mythic mob boss name
      name: "BOSS"
    rewards:
      # Here you can link the id of each reward you want to give
      - "completion_reward"
    time:
      # The maximum fight duration before despawning the boss and letting other players try
      max_boss_fight_duration:
        amount: 5
        unit: MINUTES
        # commands to execute when a player or a party fail to defeat the boss before the time expires
        time_out_commands:
          - "say FIGHT EXPIRED!"
      kick_after_completion:
        amount: 30
        unit: SECONDS

rewards: # Default section for every reward
  completion_reward:
    items:
      # This might be named as you want, the only requirement is to make it different from the others
      Example_item:
        is_mythic_item: true
        # Ignored if 'is_mythic_item' is false
        mythic_item_name: "AAA"
        # Ignored if 'is_mythic_item' is true
        type: SNOWBALL
        amount: 16
        is_glowing: false
        # Supported enchants: [PROTECTION, FIRE_PROTECTION, FEATHER_FALLING, BLAST_PROTECTION,
        #                      PROJECTILE_PROTECTION, RESPIRATION, AQUA_AFFINITY, THORNS, DEPTH_STRIDER,
        #                      FROST_WALKER, BINDING_CURSE, SHARPNESS, SMITE, BANE_OF_ARTHROPODS,
        #                      KNOCKBACK, FIRE_ASPECT, LOOTING, SWEEPING_EDGE, EFFICIENCY, SILK_TOUCH,
        #                      UNBREAKING, FORTUNE, POWER, PUNCH, FLAME, INFINITY, LUCK_OF_THE_SEA, LURE,
        #                      LOYALTY, IMPALING, RIPTIDE, CHANNELING, MULTISHOT, QUICK_CHARGE, PIERCING,
        #                      DENSITY, BREACH, WIND_BURST, MENDING, VANISHING_CURSE, SOUL_SPEED, SWIFT_SNEAK]
        enchants:
          - "PROTECTION"
        display_name: "abc" # Ignored if mythic_item is true since every MMOItem has its own displayname
        lore:
          - "def"
    experience: 1000
    commands:
      - "say BRAVO %player_name%!"